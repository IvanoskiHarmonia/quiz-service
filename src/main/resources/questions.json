[
    {
        "text": "What are the different types of variables in Java?",
        "options": [
            "Static Variables: Shared among all instances of a class, existing independently of any object.",
            "Global Variables: Also known as instance variables, unique to each class instance, and accessible throughout the class.",
            "Local Variables: Exist only within the block or method where they're declared and are not known outside it."
        ],
        "type": "MULTIPLE_CHOICE",
        "answer": "Static Variables, Global Variables, Local Variables",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What are the different types of data structures in Java?",
        "options": [
            "Stack",
            "Queue",
            "Trees",
            "HashMaps/HashSets",
            "Arrays",
            "Lists"
        ],
        "type": "MULTIPLE_CHOICE",
        "answer": "Stack, Queue, Trees, HashMaps/HashSets, Arrays, Lists",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What are the different types of control flow statements in Java?",
        "options": [
            "Sequence (Code execution top-to-bottom)",
            "Selection (Statements are executed based on value of a condition)",
            "Iteration (Statements are executed repeatedly until certain conditions are met)",
            "Jump (Statements are executed unconditionally)"
        ],
        "type": "MULTIPLE_CHOICE",
        "answer": "Sequence, Selection, Iteration, Jump",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "What are the different types of exceptions in Java?",
        "options": [
            "Checked exceptions - (Must be declared in the method signature), If a method throws checked exception, the method must either call it, or declare that it throws it.",
            "Unchecked exceptions - (Not included in the method signature), if a method throws unchecked exception, the method does not need to call it or declare it."
        ],
        "type": "MULTIPLE_CHOICE",
        "answer": "Checked exceptions, Unchecked exceptions",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "What are the different types of collections in Java?",
        "options": [
            "List",
            "Queue",
            "Stacks",
            "Arrays",
            "Maps"
        ],
        "type": "MULTIPLE_CHOICE",
        "answer": "List, Queue, Stacks, Arrays, Maps",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What are the different types of streams in Java?",
        "options": [
            "IntStream - A stream of primitive int values",
            "LongStream - A stream of primitive long values",
            "DoubleStream - A stream of primitive double values"
        ],
        "type": "MULTIPLE_CHOICE",
        "answer": "IntStream, LongStream, DoubleStream",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What do Double, String, Long wrapper classes mean? What is a wrapper class?",
        "options": [
            "Wrapper Class - A class that encapsulates a primitive data type into an object",
            "Double - Wraps a double primitive in an object",
            "String - Not a wrapper class; it's a class representing a sequence of characters",
            "Long - Wraps a long primitive in an object"
        ],
        "type": "MULTIPLE_CHOICE",
        "answer": "Wrapper Class, Double, String, Long",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What are the different types of functional interfaces in Java?",
        "options": [
            "Consumer - A functional interface with a single abstract method that takes an argument and returns void",
            "Supplier - A functional interface with a single abstract method that returns a value",
            "Predicate - A functional interface with a single abstract method that takes an argument and returns a boolean value",
            "Function - A functional interface with two abstract methods that take an argument and return a value"
        ],
        "type": "MULTIPLE_CHOICE",
        "answer": "Consumer, Supplier, Predicate, Function",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "What are the different types of lambda expressions in Java?",
        "options": [
            "Expression lambdas - Lambda expressions that can be used as expressions",
            "Method reference lambdas - Lambda expressions that can be used to refer to methods",
            "Block lambdas - Lambda expressions that can be used to group statements"
        ],
        "type": "MULTIPLE_CHOICE",
        "answer": "Expression lambdas, Method reference lambdas, Block lambdas",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "What are the different types of generics in Java?",
        "options": [
            "Parameterized types allow you to specify the type of a variable or parameter at compile time. For example, the following code declares a List variable that can only store strings: \n * List<String> names = new ArrayList<>();",
            "Wildcard types allow you to specify that a variable or parameter can be of any type. For example, the following code declares a List variable that can store any type of object: * List<?> objects = new ArrayList<>();",
            "Bounded types allow you to specify that a variable or parameter must be of a specific type or a type that is derived from a specific type. For example, the following code declares a List variable that can only store objects that are derived from the String class: * List<String> strings = new ArrayList<>();"
        ],
        "type": "MULTIPLE_CHOICE",
        "answer": "Parameterized types, Wildcard types, Bounded types",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What are the different types of annotations in Java?",
        "options": [
            "Built-in Annotations: Used by the Java compiler itself (@Override, @Deprecated, @SuppressWarnings).",
            "Meta-Annotations: Used to create custom annotations (@Retention, @Target, @Inherited, @Documented).",
            "Custom Annotations: Defined by the programmer to add metadata to Java code that can be processed by custom tools."
        ],
        "type": "MULTIPLE_CHOICE",
        "answer": "Built-in Annotations, Meta-Annotations, Custom Annotations",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "What is Java platform independence?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Java achieves platform independence through the use of bytecode. When Java source code is compiled, it's turned into bytecode that is platform-neutral. This bytecode is then interpreted by the Java Virtual Machine (JVM) on whatever device it is running, making the code executable on many different platforms without modification.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "What is an RDBMS?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "It uses a structured query language (SQL) for accessing and managing data. RDBMSs enforce data integrity and allow for complex queries, transactions, and concurrency control. They are based on the relational model proposed by E.F. Codd.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What is a NoSQL database?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "NoSQL databases are non-relational databases that are document-oriented, key-value pairs, graph databases, or wide-column stores. They are designed to be flexible, scalable, and high-performance.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What is a RESTful API?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "REST stands for Representational State Transfer. It is an architectural style for designing APIs. RESTful APIs are stateless, meaning that the server does not need to know anything about what state the client is in and vice versa. RESTful APIs use HTTP requests to perform CRUD (Create, Read, Update, Delete) operations.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What is a microservice?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "A microservice is a small, independent, and loosely coupled service that performs a single function. Microservices are independently deployable and scalable. They communicate with each other using APIs.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What is a container?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another. A Docker container image is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries, and settings.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What are the basic access specifiers for Java classes?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Public: The class is accessible by any other class.,Default (package-private): The class is only accessible by classes in the same package (if no specifier is used)., Protected: The class is accessible within its own package and by subclasses.,Private: The class is only accessible within its own class.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What are loops in Java and what are the 3 types of loops?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "For: let’s you repeat specific number of times\nWhile: repeats until loop’s condition is false\nDo-While: Similar to while loop, but it runs at least once before checking the condition which is in the end.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What is the difference between fail-fast and fail-safe iterators?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Fail-fast iterators stop working if they realize the collection they are going through is changing, while fail-safe iterators don't mind and keep going.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "What is the difference between a HashMap and a Hashtable?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "HashMap is not synchronized, while Hashtable is synchronized. This makes HashMap better for non-threaded applications, as unsynchronized Objects typically perform better than synchronized ones.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "What is the difference between a HashMap and a HashSet?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "HashMap stores key-value pairs, while HashSet stores only values. HashMap uses put() method to add elements, while HashSet uses add() method.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "What is the difference between a HashMap and a TreeMap?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "HashMap is implemented as a hash table, and a TreeMap is implemented as a red-black tree. A HashMap does not guarantee any particular order of its elements, while a TreeMap sorts its entries by their keys.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "What is the difference between a HashMap and a LinkedHashMap?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "LinkedHashMap is a subclass of HashMap that maintains a linked list of the entries in the map, in the order in which they were inserted. This allows insertion-order iteration over the map. HashMap does not guarantee any particular order of its elements.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "What is the difference between a HashMap and a WeakHashMap?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "WeakHashMap is an implementation of the Map interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the WeakHashMap.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "What is the MVC design pattern?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "MVC is a way to organize code in an application into three parts: one part for handling data (Model), one part for displaying the user interface (View), and one part for controlling how the user interface works (Controller).",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What have you built using Java?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Long time ago, for my Programming 1 class, I was able to build stock grabber, an application built in Java as a backend, and JavaFX as a frontend, In this program I was able to fix the issue of JavaFX not being able to run 2 simultaneous jobs by using multi-threading, bypassing the blocking I/O of JavaFx.\nI also recently worked on a project called Bookstore-API, I was able to lead the team to implement full bookstore functionality from wishlists, carts, profile management and so on, by using Spring boot framework, H2 as our primary database, as it was not required to have actual database in place (H2 is a in-memory database that used mostly used during initial development stages, it helps with setup, and it does not need configuration to work). To enhance the productivity of the team, and the code standards I also added GitHub Actions, which is a Continues Integration and Continuous Delivery platform that allows you automate builds, tests, and deployment pipelines. By using GitHub Actions, I was able to enforce proper code standards, which helped us to keep our code clean and easy to read. In this project, I also enforced sprint backlog, and ticketing system (similar to Jira’s way of doing tickets), that helped track our work, and prioritize more important features.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What is the difference between a class and an object?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "A class is a blueprint for an object. An object is an instance of a class. A class is a logical entity, while an object is a physical entity.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What is the difference between a class and an interface?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "A class can implement multiple interfaces, but a class can extend only one other class. An interface cannot implement another interface, while a class can implement an interface.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What is the difference between an abstract class and an interface?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "An abstract class can have instance variables that are not static and final, while an interface cannot. An abstract class can have any visibility: public, private, protected, while an interface's visibility must be public or package.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What is the difference between an abstract class and a concrete class?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "An abstract class cannot be instantiated, while a concrete class can be instantiated. An abstract class can have abstract and non-abstract methods, while a concrete class can only have non-abstract methods.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What is the difference between an abstract class and a final class?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "An abstract class cannot be instantiated, while a final class can be instantiated. An abstract class can have abstract and non-abstract methods, while a final class can only have non-abstract methods.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What does @Bean mean in spring",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "The @Bean annotation in Spring Boot is used to declare a method that will be called to create a bean. The bean can then be injected into other beans or used in other ways.",
        "difficulty": "EASY",
        "category": "SPRING"
    },
    {
        "text": "How did you design that thing? What were the key principles you followed?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "SOLID principles, Design Patterns, Clean Code, UML Diagram to represent the R-DB, Unit testing with JUnit.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "How did you test that thing?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "To test the application (Bookstore-API), I firstly introduced Unit testing using JUnit tests, next I tested the endpoints for positive and negative tests to ensure that everything works by logic as expected.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "How would you approach finding a solution to a problem/bug in your code?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Understand the problem by reproducing the bug, checking logs, and writing test cases that fail due to the bug.\n\nIn-depth Approach: Once the issue is identified, debug the code using a debugger, check version control history for recent changes that might have caused the issue, and consider the stack trace if there's an exception involved.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "Why might an SQL query suddenly begin to perform much slower than usual standards?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Look for missing indexes, query not using indexes, or increased data volume.\nIn-depth Investigation: Analyze the execution plan of the query, check for database contention or locks, and monitor the database and server performance metrics for bottlenecks.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What is the role for a ClassLoader in Java?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "It loads Java classes into memory when they are needed.\nA ClassLoader reads the bytecode of Java classes and makes them available to the JVM. It plays a critical role in the concept of Java’s runtime environment and can also be used to load classes at runtime from various sources.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "What is an Interpreter in Java?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "An interpreter translates and executes the Java bytecode line by line on the fly.\nThe Java interpreter is part of the JVM that reads the bytecode, interprets it, and executes the instructions directly on the host machine.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "How do you find memory leak in Java application?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Use profiling tools like VisualVM or Java Mission Control to monitor the heap.\nIdentify unusually long-lived objects and investigate the paths to GC roots to see why they are retained in memory.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "How do you find which part of your application/object is consuming most of your heap?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Take a heap dump and analyze it.\nTools like Eclipse Memory Analyzer (MAT) can be used to perform heap dump analysis to find objects that consume a lot of memory and to understand memory consumption patterns.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "How does Collection Framework work",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "The Collection Framework provides a set of interfaces and classes for storing and manipulating groups of data as objects.\nIt includes various interfaces like List, Set, Queue, and Map, along with their implementation classes like ArrayList, HashSet, LinkedList, PriorityQueue, HashMap, etc. These collections handle data in different ways, for example, List allows duplicate elements and maintains order, while Set does not allow duplicates and Map stores key-value pairs. The framework is designed to allow interoperability among different types of collections, algorithms for sorting and searching, and interfaces that define different collections' behavior.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "How does Concurrency API work",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "The Concurrency API provides tools for writing concurrent (multi-threaded) programs for better performance on multi-core systems.\nIntroduced mainly in java.util.concurrent package, it includes classes like ExecutorService to manage threads, ConcurrentHashMap for thread-safe collections, Future to represent the result of an asynchronous computation, and Lock for controlling access to a shared resource. It also contains tools for synchronizing thread communication like CountDownLatch, CyclicBarrier, Semaphore, and Phaser. This API is crucial for writing reliable and scalable Java applications that can handle multiple tasks simultaneously.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "Explain the concept of ‘overloading’ and ‘overriding’ in Java",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Overloading is when you define a method with same name, but different parameters.\nOverriding is a technique where you override the functionality of a method that you inherited from a parent class.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What is a JVM and how does it work?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "The Java Virtual Machine (JVM) is a core component of the Java platform that executes Java bytecode, enabling Java applications to run on any platform without needing recompilation. It handles program memory, manages execution, and ensures Java's platform independence. The JVM turns Java bytecode into machine code suitable for the specific CPU and operating system at runtime, adhering to the principle of \"Write Once, Run Anywhere\" (WORA).",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "Can you explain the difference between a HashSet and a TreeSet in Java?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "TreeSet is a set of values that are ordered, and HashSet is a set where values are not sorted/no in order.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What is a memory leak and how can you minimize them in Java?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Memory leaks in Java can arise from several scenarios. The most common cause is leaking objects, where objects are no longer needed but still occupy memory due to lingering references or improper management within the application. Circular references also contribute to memory leaks, occurring when two objects refer to each other and thus prevent each other's garbage collection, even if they are not used elsewhere. Additionally, memory leaks can result from unclosed resources, such as files or database connections, which continue to consume resources if not properly closed.\nTo minimize memory leaks in Java, several practices can be employed. Using the WeakReference class allows for references that do not prevent the garbage collection of objects, enabling their memory to be reclaimed when no longer in use. The finalize() method, called before an object is garbage collected, can be utilized for cleaning up resources. The try-with-resources statement is crucial for ensuring proper closure of resources, particularly when exceptions occur. Lastly, employing a memory profiler is a proactive approach to identifying and resolving memory leaks, providing insights into memory usage and potential issues within an application.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "How would you implement an immutable class in Java?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Declare the class as final so it can’t be extended.\nMake all of the fields private so that direct access is not allowed.\nDon’t provide setter methods for variables.\nMake all mutable fields final so that a field’s value can be assigned only once.\nInitialize all fields using a constructor method performing deep copy.\nPerform cloning of objects in the getter methods to return a copy rather than returning the actual object reference.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "Can you explain the difference between String, StringBuilder, and StringBuffer?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "String is immutable whereas StringBuffer and StringBuilder are mutable classes.\nStringBuffer is thread-safe and synchronized whereas StringBuilder is not.\nThat's why StringBuilder is faster than StringBuffer. ",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "What does it mean a class/type to be thread safe? what is thread-safe vs non-thread-safe?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Thread-Safe:\n  * A class is thread-safe if it ensures the integrity of its instances when used by multiple threads simultaneously. Internal synchronization is used to prevent concurrent access issues. For example, java.util.concurrent.ConcurrentHashMap is thread-safe as it can be accessed by many threads without external synchronization.\nNon-Thread-Safe:\n  * A class is non-thread-safe if its methods do not prevent race conditions when accessed by multiple threads at once. Users of the class must implement their own synchronization to maintain data integrity. An example is java.util.ArrayList, which requires external synchronization for concurrent modifications.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "What is the difference between an abstract class and an interface in Java?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "The main difference between an abstract class and an interface is that an abstract class can have concrete methods, while an interface can only have abstract methods.\nAbstract vs Concrete Methods: In Java, a concrete method is a method that has a body. An abstract method is a method that does not have a body.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What is the purpose of the static keyword in Java? Give an example.",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "The static keyword in Java is used to indicate that a particular member (variable or method) belongs to the class itself, rather than to instances of the class.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "Can you explain the concept of the Java Class Loader?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "It loads Java classes into memory when they are needed.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "Explain the concept of reflection in Java and where it would be useful.",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Reflection in Java is a mechanism that allows programs to inspect and modify the behavior of classes, interfaces, fields, and methods at runtime, enabling dynamic manipulation of code. It is particularly useful for scenarios like serialization, deserialization, frameworks that require a lot of boilerplate code, and when interfacing with APIs that are not known at compile time.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "What are annotations in Java? Can you provide some examples of how you’ve used them?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Annotations in Java are a form of metadata that provide information about the program but are not part of the program itself. Annotations have no direct effect on the operation of the code they annotate.\nI have used them in overriding methods, testing like @Test, @BeforeEach and so on, in Spring @Entity, @Service, and more.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "What are the benefits of using Generics in Java?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Generics enable types (classes and interfaces) to be parameters when defining classes, interfaces, and methods. This leads to stronger type checks at compile time, eliminating the risk of ClassCastException, and allowing for more generic programming. They also enable you to implement generic algorithms that work on collections of different types.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "How do you convert a JSON string to a Java object and vice versa?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "This can be done using libraries like Jackson or Gson. To convert a JSON string to a Java object, you would parse the JSON using these libraries' readValue method. To convert a Java object to a JSON string, you would use the writeValueAsString method.\n  * Gson gson = new Gson();\n  * MyObject obj = gson.fromJson(jsonString, MyObject.class);\n  * String json = gson.toJson(obj);",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What is the Java Persistence API (JPA), and why would you use it?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "JPA is a specification for accessing, persisting, and managing data between Java objects and a relational database. You would use JPA to map Java objects to database tables and to manage their persistence without dealing directly with SQL operations, which simplifies the data handling in the application.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What is Dependency Injection and how can it be implemented in Java?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Dependency Injection is a design pattern that allows a class’s dependencies to be injected at runtime, which decouples the classes' instantiation and behavior. It can be implemented in Java using frameworks like Spring, where dependencies are injected using annotations like @Autowired.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "Can you explain the concept of a Java Servlet and its life cycle?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "A Java Servlet is a Java program that extends the capabilities of servers that host applications accessed via a request-response programming model. Its life cycle includes initialization (init method), handling client requests (service method), and cleanup (destroy method).",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "How do you ensure that your Java code is thread-safe?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "To ensure thread-safety, use synchronization where necessary, use thread-safe collections like ConcurrentHashMap, write immutable classes, and use atomic variables and locks where required.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "How does the Garbage Collector work in Java, and what does it do?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "The Garbage Collector in Java automatically manages memory by deallocating objects that are no longer reachable in the application. It identifies unused objects and reclaims their memory while the program is running.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "Can you explain the differences between final, finally, and finalize?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "final: A keyword that can be used to mark a variable as unchangeable, a method as non-overridable, or a class as non-inheritable.\nfinally: A block that is used in a try-catch structure that ensures execution of code regardless of whether an exception is thrown or not.\nfinalize: A method that the garbage collector calls before memory is reclaimed, which can be overridden to clean up resources, although its use is discouraged in favor of try-with-resources.",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    },
    {
        "text": "How would you handle multiple versions of a web service in Java?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Multiple versions can be handled by versioning the API using different URL paths or parameters and maintaining different endpoints for each version.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What is the difference between == and .equals() in Java?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "== checks for reference equality, whereas .equals() checks for object content equality, which can be overridden in custom types.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "How would you troubleshoot a slow-running Java application?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "You would profile the application using tools like VisualVM, analyze heap dumps, check for inefficient algorithms, inspect database queries, and look at thread management to identify bottlenecks.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "Explain how you would use a Stream in Java 8 or higher.",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Streams provide a high-level abstraction for performing operations on collections of objects, including filtering, mapping, and reduction, in a functional style.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "Can you discuss the visibility of a protected member of a class?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "A protected member is accessible within all classes in the same package and within subclasses, even if they are in different packages.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "What are the best practices for exception handling in Java?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Always catch only those exceptions that you can actually handle, use specific exception types, never catch Throwable or Exception directly unless necessary, and avoid empty catch blocks. Always clean up after handling an exception, if needed.",
        "difficulty": "EASY",
        "category": "JAVA"
    },
    {
        "text": "How do you use Optional in Java, and what problem does it solve?",
        "options": [
            ""
        ],
        "type": "OPEN_ENDED",
        "answer": "Optional is a container object used to contain not-null objects. It provides a way to avoid NullPointerException by providing methods for checking if a value is present or not.\nUsing Optional makes the code more readable and can help in preventing null-related errors by providing a clear API for handling 'optional' values (values that can be null).",
        "difficulty": "MEDIUM",
        "category": "JAVA"
    }
]